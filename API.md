# Panda Confidential API
# Functions
## randomBytes
_**randomBytes** Length &rarr; Value_

- _Length_ `<Number>`:  Length of the output in bytes.
- __Returns__ _Value_: random data -- This is an Uint8Array of length `Length`, filled with pseudo-random values.

Generate an Uint8Array of the given length filled with pseudo-random data.  By default, this is the [implementation from TweetNaCl.js][tweetnacl-random], designed to seek out robust sources of random number generation in browser and Node.js platforms.  TweetNaCl.js will throw if it is unable to locate a suitable source on your platform.  

This method is exposed for your needs _and_ is used internally by various functions in panda-confidential to generate random values:

- [encrypt][encrypt]
- [key.Symmetric][SymmetricKey]
- [keyPair.Encryption][EncryptionKeyPair]
- [keyPair.Signature][SignatureKeyPair]

That includes key, key-pair, and encryption nonce generation.

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{randomBytes} = confidential()

do ->
  randomValue = await randomBytes 32
```

### Overriding randomBytes
You may override `randomBytes` by simply reassigning its value after you have created your instance of panda-confidential.  That change will also apply to the methods listed above.

___WARNING: Using non-robust sources of randomness will compromise the effectiveness of your encryption.  Use this feature with caution.___

##### Example
```coffeescript
import {confidential} from "panda-confidential"
import {myRandomGenerator} from "my-other-library"
c = confidential()

# Applies your random generator to panda-confidential functions
c.randomBytes = myRandomGenerator
{key, randomBytes} = c

do ->
  randomValue = await randomBytes 32
  myKey = await key.Symmetric()  # random values come from your generator.
```

## encrypt
_**encrypt** Key, Plaintext [, Encoding] &rarr; Ciphertext_

- _Key_ [`<SymmetricKey>`][classSymmetricKey] | [`<SharedKey>`][classSharedKey]:  Key to be used in the encryption operation.
- _Plaintext_ `<String>` | [`<Uint8Array>`][Uint8Array] | [`<Buffer>`][Buffer]: Data to be encrypted.
- _Encoding_ `utf8` | `base64`  (Optional): Specifies the encoding of the plaintext string.  This value defaults to `utf8` and is ignored when the plaintext is an Uint8Array or Node.js buffer.
- __Returns__ _Ciphertext_: encrypted plaintext -- This is packaged as a base64 encoded stringified object with the fields `ciphertext` and `nonce`.  `ciphertext` is a base64 encoded string of the encrypted data and `nonce` is a base64 encoded one-time use random value used in the encryption operation.  Both fields are required for decryption.

Encrypts the given data with the given key.  

When a [symmetric key][classSymmetricKey] is used, `encrypt` uses [symmetric encryption][tweetnacl-secretbox] with a random nonce [it generates][randombytes].

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{encrypt} = confidential()

do ->
  # Somehow get the symmetric key for your setup.  See key.Symmetric() for generating keys suitable for symmetric encryption.
  myKey = lookupSymmetricKey()

  # Person A symmetrically encrypts their data.
  message = "Hello World!"
  ciphertext = await encrypt myKey, message
```


When a [shared key][classSharedKey] is used, `encrypt` uses [asymmetric encryption][tweetnacl-box-after] with a random nonce [it generates][randombytes].

___The private keys you generate for signing are _not_ suitable for encryption.___

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{key, encrypt} = confidential()

do ->
  # Somehow get person A's private key and person B's public key. See keyPair.Encryption() for generating key pairs suitable for public key encryption.
  A_private = lookupPrivateKey "A"
  B_public = lookupPublicKey "B"
  message = "Hello World!"

  # Person A encrypts the message for person B by making a shared key out of their _private_ key and B's _public_ key.
  sharedKey = key.Shared A_private, B_public
  ciphertext = await encrypt sharedKey, message
```


## decrypt
_**decrypt** Key, Blob [, Encoding] &rarr; Plaintext_

- _Key_ [`<SymmetricKey>`][classSymmetricKey] | [`<SharedKey>`][classSharedKey]  Key to be used in decryption operation.
- _Blob_ `<String>` | [`<Uint8Array>`][Uint8Array] | [`<Buffer>`][Buffer] Data to be decrypted.  Expected to be the output generated by [encrypt][encrypt].
- _Encoding_ `utf8` | `base64` | `binary`  (Optional) Specifies the encoding of the output plaintext string.  This value defaults to `utf8`.  The value `binary` causes `decrypt` to return the plaintext as an Uint8Array.
- __Returns__ _Plaintext_: decoded ciphertext -- This is a string with the specified encoding, which defaults to `utf8`.  Selecting the encoding `binary` causes `decrypt` to return the plaintext as an Uint8Array.

Decrypts the given data with the given key.  

When a [symmetric key][classSymmetricKey] is used, `decrypt` uses a [symmetric decryption operation][tweetnacl-secretbox-open].

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{decrypt} = confidential()

do ->
  # Somehow get the symmetric key for your setup.  See key.Symmetric() for generating keys suitable for symmetric encryption.
  myKey = lookupSymmetricKey()

  # Somehow fetch the ciphertext from the symmetric encryption operation.
  ciphertext = fetchCiphertextFromDB()

  # Person A symmetrically decrypts their data.
  plaintext = await decrypt myKey, ciphertext
```

When a [shared key][classSharedKey] is used, `decrypt` uses an [asymmetric decryption operation][tweetnacl-box-open-after].

___The private keys you generate for signing are _not_ suitable for encryption.___

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{key, decrypt} = confidential()

do ->
  # Somehow get person A's public key and person B's private key. See keyPair.Encryption() for generating key pairs suitable for public key encryption.
  A_public = lookupPublicKey "A"
  B_private = lookupPrivateKey "B"

  # Somehow get a message from person A.
  ciphertext = fetchCiphertext()

  # Person B decrypts the message from person A by making a shared key out of A's _public_ key and their _private_ key.
  sharedKey = key.Shared A_public, B_private
  message = await decrypt sharedKey, ciphertext
```

## sign
_**sign** KeyPair [or PrivateKey, PublicKey], Message [, Encoding] &rarr; SignedMessage_

- _KeyPair_ [`<SignatureKeyPair>`][classSignatureKeyPair]:  The private and public keys of a single person wishing to sign the Message.  If you supply this, you do not need to provide the keys separately.
- _PrivateKey_ [`<PrivateKey>`][classPrivateKey]:  The private key of the person wishing to sign the message.  If you do not provide the private-public key pair directly, you must supply them individually here.
- _PublicKey_ [`<PublicKey>`][classPublicKey]:  The public key of the person wishing to sign the message.  If you do not provide the private-public key pair directly, you must supply them individually here.
- _Message_ `<String>` | [`<Uint8Array>`][Uint8Array] | [`<Buffer>`][Buffer] | [`<SignedMessage>`][classSignedMessage]: Message to be signed.
- _Encoding_ `utf8` | `base64`  (Optional): Specifies the encoding of the Message string.  This value defaults to `utf8` and is ignored when the Message is an Uint8Array, Node.js buffer, or SignedMessage.
- __Returns__ _SignedMessage_: This returns an instance of [SignedMessage][classSignedMessage] containing the Message, its original encoding, a list of the public keys of the signatories, and a list of the signatures.

Signs the given message with the given private-signing-key using [TweetNaCl.js signing implementation][tweetnacl-sign].  You may provide a signing key-pair, or provide the private and public keys as separate arguments.  

___The private keys you generate for encryption are _not_ suitable for signing.___

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{sign} = confidential()

do ->
  # Somehow get the signing key-pair for person A.  See keypair.Signature() for generating keys suitable for signing.
  A_KeyPair = lookupKeyPair()

  # Person A signs a message.
  message = "Hello World!"
  signedMsg = sign A_KeyPair, message

  # The SignedMessage class holds instantiated data in binary, but you may retrieve the message or convert the whole data to a base64 blob at any time.
  msg = signedMsg.dumpMessage()  # utf8 encoded `message` field
  blob = signedMsg.dump()        # base64 encoded stringified object
```

Multiple people can sign a message, so `sign` also operates on previously signed messages.  The output is the same SignedMessage instance, with an additional signature and matching public key in its lists.

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{sign, signedMessage} = confidential()

do ->
  # Somehow get the signing key-pair for person B.  See keypair.Signature() for generating keys suitable for signing.
  B_KeyPair = lookupKeyPair()

  # Get the previously signed message.  If you converted it to a base64 string blob for transport, you can re-instantiate it.
  blob = fetchSignedMessageBlob()
  signedMsg = signedMessage blob  # Now we have a SignedMessage instance.
  final = sign B_KeyPair, signedMsg

  # The result has the same message and encoding fields, but now has an additional set of signature + public key.
  final.signatures.length == 2  # true
  final.publicKeys.length == 2  # true
```

## verify
_**verify** SignedMessage &rarr; Result_

- _SignedMessage_ [`<SignedMessage>`][classSignedMessage]: Signed message to be verified.
- __Returns__ _Result_: The boolean result of the verification process.  If the signatures checkout, `true`. Otherwise, `false`.

Verifies the signatures against the original message and the attached public keys.  Verification occurs via [TweetNaCl.js signing implementation][tweetnacl-verify].  Everything needed to verify message integrity exists within the SignedMessage instance, but it is up to you to verify the public keys are correct.

> See [key.equal()][equal] for information on key comparison.

___The private keys you generate for encryption are _not_ suitable for signing.___

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{verify, signedMessage} = confidential()

do ->
  # Get the signed message.  If you converted it to a base64 string blob for transport, you can re-instantiate it.
  blob = fetchSignedMessageBlob()
  signedMsg = signedMessage blob  # Now we have a SignedMessage instance.
  isValid = verify signedMsg

  if isValid
    # Return verified message.
    signedMsg.dumpMessage()
  else
    # Uh oh.
    throw new Error "Unable to verify message signatures."
```

## encode
_**encode** Encoding, Data &rarr; Result_

- _Encoding_ `utf8` | `base64` | `binary`: The desired encoding of the Result.
- _Data_ [`<Uint8Array>`][Uint8Array] | [`<Buffer>`][Buffer] | `<String>` | `<Object>`: The Data to be encoded.  This is usually binary data, but `encode` can process other types.
- __Returns__ _Result_: The encoded Result of the input Data, usually a string.

Encodes an input into a desired output.  This generic is designed to be flexible enough to handle many input types and is used extensively to construct the `encrypt`-`decrypt` and `sign`-`verify` generics, as well as the key and key-pair class constructors.  It is exposed to allow extensions to panda-confidential access to its expressive power.  

The underlying `utf8` and `base64` encoding is handled by the [TweetNaCl-Utils-JS][tweetnacl-utils] helpers, written in [Universal JavasScript][universal].

When an Uint8Array or Node.js Buffer is input:
- `utf8`: `encode` outputs a UTF8 encoded string.
- `base64`: `encode` outputs a Base64 encoded string.
- `binary`: `encode` is a no-op.

When a string is input:
- `utf8`: `encode` decodes the string -- assuming Base64 encoding -- and outputs a UTF8 encoded string.
- `base64`: `encode` decodes the string -- assuming UTF8 encoding -- and outputs a Base64 encoded string.

When an object is input:
- `encode` outputs a base64 encoded, stringified version of the object.  In this case, you are not required to specify a encoding format.

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{encode} = confidential()

do ->
  data =
    new Uint8Array [ 72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33 ]

  string = encode "utf8", data
  string == "Hello World!"  # true

  blob = encode message: "Hello World!"
  blob == "eyJtZXNzYWdlIjoiSGVsbG8gV29ybGQhIn0="        # true
  encode("utf8", blob) == '{"message":"Hello World!"}'  # true
```
## decode
_**decode** Encoding, Data &rarr; Result_

- _Encoding_ `utf8` | `base64` | `binary`: The encoding of the input Data.
- _Data_ `<String>` | `<Object>` | [`<Uint8Array>`][Uint8Array] | [`<Buffer>`][Buffer]: The data to be decoded. This is usually a string, but `decode` can process other types.
- __Returns__ _Result_: The decoded Result of the input data, usually binary data.

Decodes an input into a desired output.  This generic is designed to be flexible enough to handle many input types and is used extensively to construct the `encrypt`-`decrypt` and `sign`-`verify` generics, as well as the key and key-pair class constructors.  It is exposed to allow extensions to panda-confidential access to its expressive power.  

The underlying `utf8` and `base64` decoding is handled by the [TweetNaCl-Utils-JS][tweetnacl-utils] helpers, written in [Universal JavasScript][universal].

When an Uint8Array or Node.js Buffer is input:
- `decode` is a no-op, regardless of the encoding specified.

When a string is input:
- `utf8`: `decode` decodes the string -- assuming UTF8 encoding -- and outputs an Uint8Array of the resulting data.
- `base64`: `decode` decodes the string -- assuming Base64 encoding -- and outputs an Uint8Array of the resulting data.
- `binary`: `deocde` is a no-op.

When an object is input:
- `decode` first stringifies the object and then utf8 decodes it to output an Uint8Array of the resulting data.  In this case, you are not required to specify a decoding format.

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{decode, key} = confidential()

do ->
  string = "Hello World!"
  data =
    new Uint8Array [ 72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33 ]

  key.equal decode("utf8", string), data    # true

  data = decode "utf8", '{"message":"Hello World!"}'
  data2 = decode message: "Hello World!"
  key.equal data, data2    # true
```

## Key Type System
panda-confidential uses a key type system to allow the generics -- `encrypt`, `decrypt`, `sign`, and `verify` -- to select the appropriate action.  This type system is implemented in [key and key-pair classes](#classes), but the following functions are exposed to allow you to access their constructors more effectively.

## key


### key.Symmetric
_**key.Symmetric** [Key] &rarr; SymmetricKey_

- _Key_ `<String>` | [`<Uint8Array>`][Uint8Array] | [`<Buffer>`][Buffer]: (Optional) A key value literal for this key.  May be a Base64 encoded string or a binary array.
- __Returns__ _SymmetricKey_: This returns an instance of [SymmetricKey][classSymmetricKey]

When you invoke this function without passing any arguments, panda-confidential will generate a key for you suitable for symmetric encryption.  Though the default TweetNaCl.js implementation of randomBytes is synchronous, panda-confidential wraps it with a promise to allow extension via an asynchronous means.

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{key} = confidential()

do ->
  # Generate a symmetric key from a key literal.
  key1 = key.Symmetric "WM4YL5yo+6yKAFaIZGp3QPbcjW9ICEGXlxR/Odnr2+k="

  # Or generate a key from randomBytes
  key2 = await key.Symmetric()
```


### key.Private
_**key.Private** Key &rarr; PrivateKey_

- _Key_ `<String>` | [`<Uint8Array>`][Uint8Array] | [`<Buffer>`][Buffer]: A key value literal for this key.  May be a Base64 encoded string or a binary array.
- __Returns__ _PrivateKey_: This returns an instance of [PrivateKey][classPrivateKey]

This is one half of a key pair.  The key literal argument is required.  See [`keyPair.Encryption`][EncryptionKeyPair] or [`keyPair.Signature`][SignatureKeyPair] for information about generating this kind of key from `randomBytes`.

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{key} = confidential()

do ->
  # Generate a Private key from a key literal.
  key1 = key.Private "WM4YL5yo+6yKAFaIZGp3QPbcjW9ICEGXlxR/Odnr2+k="
```


### key.Public
_**key.Public** Key &rarr; PublicKey_

- _Key_ `<String>` | [`<Uint8Array>`][Uint8Array] | [`<Buffer>`][Buffer]: A key value literal for this key.  May be a Base64 encoded string or a binary array.
- __Returns__ _PublicKey_: This returns an instance of [PublicKey][classPublicKey]

This is one half of a key pair.  The key literal argument is required.  See [`keyPair.Encryption`][EncryptionKeyPair] or [`keyPair.Signature`][SignatureKeyPair] for information about generating this kind of key from `randomBytes`.

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{key} = confidential()

do ->
  # Generate a Public key from a key literal.
  key1 = key.Public "WM4YL5yo+6yKAFaIZGp3QPbcjW9ICEGXlxR/Odnr2+k="
```


### key.Shared
_**key.Shared** Key1, Key2 [or Key] &rarr; SharedKey_

- _Key_ `<String>` | [`<Uint8Array>`][Uint8Array] | [`<Buffer>`][Buffer]: A key value literal for this key.  May be a Base64 encoded string or a binary array.
- _Key1_ [`<PrivateKey>`][classPrivateKey] | [`<PublicKey>`][classPublicKey]: A public or private key instance used in the formation of the shared key.  If this one is private, the other must be a public key.  Or vice versa.
- _Key2_ [`<PublicKey>`][classPublicKey] | [`<PrivateKey>`][classPrivateKey]: A public or private key instance used in the formation of the shared key.  If this one is private, the other must be a public key.  Or vice versa.
- __Returns__ _SharedKey_: This returns an instance of [SharedKey][classSharedKey]

This key type is used in [TweetNaCl.js public key encryption interface][tweetnacl-box].  It is a special key formed by using one person's private key and another's public key, yielding a shared secret.

To use this method you may either:
1. Pass in a key literal, like the other keys
2. Pass in a private key from person A and a public key from person B to [algorithmically generate the shared key][tweetnacl-box-before]

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{key} = confidential()

do ->
  # Generate encryption key pairs for persons A and B.
  A = await keyPair.Encryption()
  B = await keyPair.Encryption()
  shared = key.Shared A.privateKey, B.publicKey
```
### key.isSymmetric
### key.isPrivate
### key.isPublic
### key.isShared
### key.equal

## keyPair

### keyPair.Encryption
### keyPair.Signature
### keyPair.isEncryption
### keyPair.isSignature

# Helpers

## nacl
## hash
## isData
## signedMessage
## isSignedMessage

# Classes
Classes in panda-confidential are lightweight wrappers for values.  They provide a type-system to support the generics (`encrypt`, `decrypt`, `sign`, and `verify`) and a couple of convenience methods.  Their constructors ready values for use with the underlying TweetNaCl.js invocations (`Uint8Array`), but you can easily access the value by `dump`ing it into a form that's easier for transport or placing into a datastore.

## Key
### Properties
  - `key` - key's value stored as an Uint8Array of bytes, ready for use within TweetNaCl.js.

### Methods
- `dump`
  - _dump &rarr; Value_

   outputs the value of `key` as a Base64 encoded string.

### Description
Base class for all keys in panda-confidential.  It stores a decoded key ready for use in TweetNaCl.js functions, and can output a Base64 encoded string for transport.  

This class is not used directly within panda-confidential, but its descendants all share its interface.

## SymmetricKey
_extends [Key][classKey]_

### Description
This key type is used in [TweetNaCl.js symmetric encryption interface][tweetnacl-secretbox].  This is the key type required by [`encrypt`][encrypt] to perform symmetric encryption.

## PrivateKey
_extends [Key][classKey]_

### Description
This key type is used in [TweetNaCl.js public key encryption interface][tweetnacl-box], along with [PublicKey][classPublicKey]

## PublicKey
_extends [Key][classKey]_

### Description
This key type is used in [TweetNaCl.js public key encryption interface][tweetnacl-box], along with [PrivateKey][classPrivateKey]

## SharedKey
_extends [Key][classKey]_

### Description
This key type is used in [TweetNaCl.js public key encryption interface][tweetnacl-box].  It is a special key formed by using one person's private key and another's public key, yielding a shared secret.  This is the key required by [`encrypt`][encrypt] to perform asymmetric encryption.

## KeyPair
### Properties
  - `privateKey` - The private key of this key pair.  This is an instance of [PrivateKey][classPrivateKey].
  - `publicKey` - The public key of this key pair.  This is an instance of [PublicKey][classPublicKey].

### Methods
- `dump`
  - _dump &rarr; Value_

   outputs all the properties of this instance as a Base64 encoded stringified object.

### Description
Base class for all key-pairs in panda-confidential.  It stores pair of [PrivateKey][classPrivateKey] and [PublicKey][classPublicKey] classes.  Recall they are decoded values ready for use in TweetNaCl.js functions, and can be output a Base64 encoded string for transport.  

This class is not used directly within panda-confidential, but its descendants all share its interface.

## EncryptionKeyPair
_extends [KeyPair][classKeyPair]_

This key pair is used by panda-confidential for public key encryption.  You may generate a pair by invoking [`keyPair.Encryption()`][EncryptionKeyPair].

___The key pair you generate for encryption is _not_ suitable for signing.___

## SignatureKeyPair
_extends [KeyPair][classKeyPair]_

This key pair is used by panda-confidential for message signing.  You may generate a pair by invoking [`keyPair.Signature()`][SignatureKeyPair].

___The key pair you generate for signing is _not_ suitable for encryption.___

## SignedMessage
### Properties
  - `message` - The message that has been signed, stored as an Uint8Array of bytes, ready for use within TweetNaCl.js.
  - `encoding` - The encoding of the original message.  When this value is `binary`, dumping the message will return an Uint8Array.
  - `signatures` - A list of signatures generated by signing the `message` with a private key.  These are stored as Uint8Arrays, ready for use within TweetNaCl.js.
  - `publicKeys` - A list of the public keys used to validate the matching signatures in the `signatures` list. These are stored as Uint8Arrays, ready for use within TweetNaCl.js.

### Methods
- `dump`
  - _dump &rarr; Value_

   outputs all the properties of this instance as a Base64 encoded stringified object.

- `dumpMessage`
  - _dumpMessage &rarr; Value_

  outputs the message as a string with the encoding matching the value of the `encoding` property.  If `encoding` is `binary`, this method returns the message as an Uint8Array.

### Description
Signed messages are self-contained entities that have everything you need to check their integrity.  When passed to [`verify`][verify], it matches all the public keys to the signatures and uses TweetNaCl.js to validate the signatures.

While a signed message can be verified to be internally self-consistent, it is up to you to verify the public keys belong to whoever claims to have sent the message.


[randombytes]: #randombytes
[encrypt]: #encrypt
[decrypt]: #decrypt
[sign]: #sign
[verify]: #verify
[encode]: #encode
[decode]: #decode
[isData]: #isdata
[hash]: #hash
[nacl]: #nacl

[SymmetricKey]: #keysymmetric
[PrivateKey]: #keyprivate
[PublicKey]: #keypublic
[SharedKey]: #keyshared
[EncryptionKeyPair]: #keypairencryption
[SignatureKeyPair]: #keypairsignature
[isSymmetric]: #keyissymmetric
[isPrivate]: #keyisprivate
[isPublic]: #keyisprivate
[isShared]: #keyisshared
[isEncryption]: #keypairisencryption
[isSignature]: #keypairissignature
[equal]: #keyequal

[signedMessage]: #signedmessage
[isSignedMessage]: #issignedmessage

[classes]: #classes
[classKey]: #key-1
[classSymmetricKey]: #symmetrickey
[classPrivateKey]: #privatekey
[classPublicKey]: #publickey
[classSharedKey]: #sharedkey
[classKeyPair]: #keypair-1
[classEncryptionKeyPair]: #encryptionkeypair
[classSignatureKeyPair]: #signaturekeypair
[classSignedMessage]: #signedmessage-1


[Uint8Array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array
[Buffer]:https://nodejs.org/api/buffer.html
[universal]: https://medium.com/@ghengeveld/isomorphism-vs-universal-javascript-4b47fb481beb


[tweetnacl-random]: https://github.com/dchest/tweetnacl-js#random-bytes-generation
[tweetnacl-box]:https://github.com/dchest/tweetnacl-js#public-key-authenticated-encryption-box
[tweetnacl-secretbox]: https://github.com/dchest/tweetnacl-js#naclsecretboxmessage-nonce-key
[tweetnacl-box-before]:https://github.com/dchest/tweetnacl-js#naclboxbeforetheirpublickey-mysecretkey
[tweetnacl-box-after]: https://github.com/dchest/tweetnacl-js#naclboxaftermessage-nonce-sharedkey
[tweetnacl-secretbox-open]: https://github.com/dchest/tweetnacl-js#naclsecretboxopenbox-nonce-key
[tweetnacl-box-open-after]: https://github.com/dchest/tweetnacl-js#naclboxopenafterbox-nonce-sharedkey
[tweetnacl-sign]: https://github.com/dchest/tweetnacl-js#naclsigndetachedmessage-secretkey
[tweetnacl-verify]: https://github.com/dchest/tweetnacl-js#naclsigndetachedverifymessage-signature-publickey
[tweetnacl-utils]: https://github.com/dchest/tweetnacl-util-js#documentation
