# Panda Confidential API

## randomBytes

## encrypt
_**encrypt** Key, Plaintext [, Encoding] &rarr; Ciphertext_

- _Key_ [`<SymmetricKey>`][SymmetricKey] | [`<SharedKey>`][SharedKey]:  Key to be used in the encryption operation.
- _Plaintext_ `<String>` | [`<Uint8Array>`][Uint8Array] | [`<Buffer>`][Buffer]: Data to be encrypted.
- _Encoding_ `utf8` | `base64`  (Optional): Specifies the encoding of the plaintext string.  This value defaults to `utf8` and is ignored when the plaintext is an Uint8Array or Node.js buffer.
- __Returns__ _Ciphertext_: encrypted plaintext -- This is packaged as a base64 encoded stringified object with the fields `ciphertext` and `nonce`.  `ciphertext` is a base64 encoded string of the encrypted data and `nonce` is a base64 encoded one-time use random value used in the encryption operation.  Both fields are required for decryption.

Encrypts the given data with the given key.  

When a [symmetric key][SymmetricKey] is used, `encrypt` uses [symmetric encryption][secretbox] with a random nonce [it generates][randombytes].

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{encrypt} = confidential()

do ->
  # Somehow get the symmetric key for your setup.  See key.Symmetric() for generating keys suitable for symmetric encryption.
  myKey = lookupSymmetricKey()

  # Person A symmetrically encrypts their data.
  message = "Hello World!"
  ciphertext = await encrypt myKey, message
```


When a [shared key][SharedKey] is used, `encrypt` uses [asymmetric encryption][box-after] with a random nonce [it generates][randombytes].

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{key, encrypt} = confidential()

do ->
  # Somehow get person A's private key and person B's public key. See keyPair.Encryption() for generating key pairs suitable for public key encryption.
  A_private = lookupPrivateKey "A"
  B_public = lookupPublicKey "B"
  message = "Hello World!"

  # Person A encrypts the message for person B by making a shared key out of their _private_ key and B's _public_ key.
  sharedKey = key.Shared A_private, B_public
  ciphertext = await encrypt sharedKey, message
```


## decrypt
> _**decrypt** Key, Blob [, Encoding] &rarr; Plaintext_

- _Key_ [`<SymmetricKey>`][SymmetricKey] | [`<SharedKey>`][SharedKey]  Key to be used in decryption operation.
- _Blob_ `<String>` | [`<Uint8Array>`][Uint8Array] | [`<Buffer>`][Buffer] Data to be decrypted.  Expected to be the output generated by [encrypt][encrypt].
- _Encoding_ `utf8` | `base64` | `binary`  (Optional) Specifies the encoding of the output plaintext string.  This value defaults to `utf8`.  The value `binary` causes `decrypt` to return the plaintext as an Uint8Array.
- __Returns__ _Plaintext_: decoded ciphertext -- This is a string with the specified encoding, which defaults to `utf8`.  Selecting the encoding `binary` causes `decrypt` to return the plaintext as an Uint8Array.

Decrypts the given data with the given key.  

When a [symmetric key][SymmetricKey] is used, `decrypt` uses a [symmetric decryption operation][secretbox-open]].

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{decrypt} = confidential()

do ->
  # Somehow get the symmetric key for your setup.  See key.Symmetric() for generating keys suitable for symmetric encryption.
  myKey = lookupSymmetricKey()

  # Somehow fetch the ciphertext from the symmetric encryption operation.
  ciphertext = fetchCiphertextFromDB()

  # Person A symmetrically decrypts their data.
  plaintext = await decrypt myKey, ciphertext
```

When a [shared key][SharedKey] is used, `decrypt` uses an [asymmetric decryption operation][box-open-after].

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{key, decrypt} = confidential()

do ->
  # Somehow get person A's public key and person B's private key. See keyPair.Encryption() for generating key pairs suitable for public key encryption.
  A_public = lookupPublicKey "A"
  B_private = lookupPrivateKey "B"

  # Somehow get a message from person A.
  ciphertext = fetchCiphertext()

  # Person B decrypts the message from person A by making a shared key out of A's _public_ key and their _private_ key.
  sharedKey = key.Shared A_public, B_private
  message = await decrypt sharedKey, ciphertext
```

## Key Type System

## key

### Symmetric
### Private
### Public
### Shared
### isSymmetric
### isPrivate
### isPublic
### isShared

## keyPair

### Encryption
### Signature
### isEncryption
### isSignature

[random-bytes]: #randombytes
[encrypt]: #encrypt
[decrypt]: #decrypt
[sign]: #sign
[verify]: #verify
[encode]: #encode
[decode]: #decode

[SymmetricKey]: #symmetric
[PrivateKey]: #private
[PublicKey]: #public
[SharedKey]: #shared
[Uint8Array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array


[Buffer]:https://nodejs.org/api/buffer.html
[tweetnacl-random]: https://github.com/dchest/tweetnacl-js#random-bytes-generation
[secretbox]: https://github.com/dchest/tweetnacl-js#naclsecretboxmessage-nonce-key
[box-after]: https://github.com/dchest/tweetnacl-js#naclboxaftermessage-nonce-sharedkey
[secretbox-open]: https://github.com/dchest/tweetnacl-js#naclsecretboxopenbox-nonce-key
[box-open-after]:https://github.com/dchest/tweetnacl-js#naclboxopenafterbox-nonce-sharedkey
