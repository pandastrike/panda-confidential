# Panda Confidential API
# Functions
## randomBytes
_**randomBytes** Length &rarr; Value_

- _Length_ `<Number>`:  Length of the output in bytes.
- __Returns__ _Value_: random data -- This is an Uint8Array of length `Length`, filled with pseudo-random values.

Generate a Uint8Array of the given length filled with pseudo-random data.  By default, this is the [implementation from TweetNaCl.js][tweetnacl-random], designed to seek out robust sources of random number generation in browser and Node.js platforms.  TweetNaCl.js will throw if it is unable to locate a suitable source on your platform.  

This method is exposed for your needs _and_ is used internally by various functions in panda-confidential to generate random values:

- [encrypt][encrypt]
- [key.Symmetric][SymmetricKey]
- [keyPair.Encryption][EncryptionKeyPair]
- [keyPair.Signature][SignatureKeyPair]

That includes key, key-pair, and encryption nonce generation.

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{randomBytes} = confidential()

do ->
  randomValue = await randomBytes 32
```

### Overriding randomBytes
You may override `randomBytes` by simply reassigning its value after you have created your instance of panda-confidential.  That change will also apply to the methods listed above.

___WARNING: Using non-robust sources of randomness will compromise the effectiveness of your encryption.  Use this feature with caution.___

##### Example
```coffeescript
import {confidential} from "panda-confidential"
import {myRandomGenerator} from "my-other-library"
c = confidential()

# Applies your random generator to panda-confidential functions
c.randomBytes = myRandomGenerator
{key, randomBytes} = c

do ->
  randomValue = await randomBytes 32
  myKey = await key.Symmetric()  # random values come from your generator.
```

## encrypt
_**encrypt** Key, Plaintext [, Encoding] &rarr; Ciphertext_

- _Key_ [`<SymmetricKey>`][SymmetricKey] | [`<SharedKey>`][SharedKey]:  Key to be used in the encryption operation.
- _Plaintext_ `<String>` | [`<Uint8Array>`][Uint8Array] | [`<Buffer>`][Buffer]: Data to be encrypted.
- _Encoding_ `utf8` | `base64`  (Optional): Specifies the encoding of the plaintext string.  This value defaults to `utf8` and is ignored when the plaintext is an Uint8Array or Node.js buffer.
- __Returns__ _Ciphertext_: encrypted plaintext -- This is packaged as a base64 encoded stringified object with the fields `ciphertext` and `nonce`.  `ciphertext` is a base64 encoded string of the encrypted data and `nonce` is a base64 encoded one-time use random value used in the encryption operation.  Both fields are required for decryption.

Encrypts the given data with the given key.  

When a [symmetric key][SymmetricKey] is used, `encrypt` uses [symmetric encryption][tweetnacl-secretbox] with a random nonce [it generates][randombytes].

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{encrypt} = confidential()

do ->
  # Somehow get the symmetric key for your setup.  See key.Symmetric() for generating keys suitable for symmetric encryption.
  myKey = lookupSymmetricKey()

  # Person A symmetrically encrypts their data.
  message = "Hello World!"
  ciphertext = await encrypt myKey, message
```


When a [shared key][SharedKey] is used, `encrypt` uses [asymmetric encryption][tweetnacl-box-after] with a random nonce [it generates][randombytes].

___The private keys you generate for signing are _not_ suitable for encryption.___

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{key, encrypt} = confidential()

do ->
  # Somehow get person A's private key and person B's public key. See keyPair.Encryption() for generating key pairs suitable for public key encryption.
  A_private = lookupPrivateKey "A"
  B_public = lookupPublicKey "B"
  message = "Hello World!"

  # Person A encrypts the message for person B by making a shared key out of their _private_ key and B's _public_ key.
  sharedKey = key.Shared A_private, B_public
  ciphertext = await encrypt sharedKey, message
```


## decrypt
_**decrypt** Key, Blob [, Encoding] &rarr; Plaintext_

- _Key_ [`<SymmetricKey>`][SymmetricKey] | [`<SharedKey>`][SharedKey]  Key to be used in decryption operation.
- _Blob_ `<String>` | [`<Uint8Array>`][Uint8Array] | [`<Buffer>`][Buffer] Data to be decrypted.  Expected to be the output generated by [encrypt][encrypt].
- _Encoding_ `utf8` | `base64` | `binary`  (Optional) Specifies the encoding of the output plaintext string.  This value defaults to `utf8`.  The value `binary` causes `decrypt` to return the plaintext as an Uint8Array.
- __Returns__ _Plaintext_: decoded ciphertext -- This is a string with the specified encoding, which defaults to `utf8`.  Selecting the encoding `binary` causes `decrypt` to return the plaintext as an Uint8Array.

Decrypts the given data with the given key.  

When a [symmetric key][SymmetricKey] is used, `decrypt` uses a [symmetric decryption operation][tweetnacl-secretbox-open].

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{decrypt} = confidential()

do ->
  # Somehow get the symmetric key for your setup.  See key.Symmetric() for generating keys suitable for symmetric encryption.
  myKey = lookupSymmetricKey()

  # Somehow fetch the ciphertext from the symmetric encryption operation.
  ciphertext = fetchCiphertextFromDB()

  # Person A symmetrically decrypts their data.
  plaintext = await decrypt myKey, ciphertext
```

When a [shared key][SharedKey] is used, `decrypt` uses an [asymmetric decryption operation][tweetnacl-box-open-after].

___The private keys you generate for signing are _not_ suitable for encryption.___

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{key, decrypt} = confidential()

do ->
  # Somehow get person A's public key and person B's private key. See keyPair.Encryption() for generating key pairs suitable for public key encryption.
  A_public = lookupPublicKey "A"
  B_private = lookupPrivateKey "B"

  # Somehow get a message from person A.
  ciphertext = fetchCiphertext()

  # Person B decrypts the message from person A by making a shared key out of A's _public_ key and their _private_ key.
  sharedKey = key.Shared A_public, B_private
  message = await decrypt sharedKey, ciphertext
```

## sign
_**sign** KeyPair [or PrivateKey, PublicKey], Message [, Encoding] &rarr; SignedMessage_

- _KeyPair_ [`<SignatureKeyPair>`][SignatureKeyPair]:  The private and public keys of a single person wishing to sign the Message.  If you supply this, you do not need to provide the keys separately.
- _PrivateKey_ [`<PrivateKey>`][PrivateKey]:  The private key of the person wishing to sign the message.  If you do not provide the private-public key pair directly, you must supply them individually here.
- _PublicKey_ [`<PublicKey>`][PublicKey]:  The public key of the person wishing to sign the message.  If you do not provide the private-public key pair directly, you must supply them individually here.
- _Message_ `<String>` | [`<Uint8Array>`][Uint8Array] | [`<Buffer>`][Buffer] | [`<SignedMessage>`][classSignedMessage]: Message to be signed.
- _Encoding_ `utf8` | `base64`  (Optional): Specifies the encoding of the Message string.  This value defaults to `utf8` and is ignored when the Message is an Uint8Array, Node.js buffer, or SignedMessage.
- __Returns__ _SignedMessage_: This returns an instance of [SignedMessage][classSignedMessage] containing the Message, its original encoding, a list of the public keys of the signatories, and a list of the signatures.

Signs the given message with the given private-signing-key using [TweetNaCl.js signing implementation][tweetnacl-sign].  You may provide a signing key-pair, or provide the private and public keys as separate arguments.  

___The private keys you generate for encryption are _not_ suitable for signing.___

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{sign} = confidential()

do ->
  # Somehow get the signing key-pair for person A.  See keypair.Signature() for generating keys suitable for signing.
  A_KeyPair = lookupKeyPair()

  # Person A signs a message.
  message = "Hello World!"
  signedMsg = sign A_KeyPair, message

  # The SignedMessage class holds instantiated data in binary, but you may retrieve the message or convert the whole data to a base64 blob at any time.
  msg = signedMsg.dumpMessage()  # utf8 encoded `message` field
  blob = signedMsg.dump()        # base64 encoded stringified object
```

Multiple people can sign a message, so `sign` also operates on previously signed messages.  The output is the same SignedMessage instance, with an additional signature and matching public key in its lists.

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{sign, signedMessage} = confidential()

do ->
  # Somehow get the signing key-pair for person B.  See keypair.Signature() for generating keys suitable for signing.
  B_KeyPair = lookupKeyPair()

  # Get the previously signed message.  If you converted it to a base64 string blob for transport, you can re-instantiate it.
  blob = fetchSignedMessageBlob()
  signedMsg = signedMessage blob  # Now we have a SignedMessage instance.
  final = sign B_KeyPair, signedMsg

  # The result has the same message and encoding fields, but now has an additional set of signature + public key.
  final.signatures.length == 2  # true
  final.publicKeys.length == 2  # true
```

## verify
_**verify** SignedMessage &rarr; Result_

- _SignedMessage_ [`<SignedMessage>`][classSignedMessage]: Signed message to be verified.
- __Returns__ _Result_: The boolean result of the verification process.  If the signatures checkout, `true`. Otherwise, `false`.

Verifies the signatures against the original message and the attached public keys.  Verification occurs via [TweetNaCl.js signing implementation][tweetnacl-verify].  Everything needed to verify message integrity exists within the SignedMessage instance, but it is up to you to verify the public keys are correct.

> See [key.equal()][equal] for information on key comparison.

___The private keys you generate for encryption are _not_ suitable for signing.___

##### Example
```coffeescript
import {confidential} from "panda-confidential"
{verify, signedMessage} = confidential()

do ->
  # Get the signed message.  If you converted it to a base64 string blob for transport, you can re-instantiate it.
  blob = fetchSignedMessageBlob()
  signedMsg = signedMessage blob  # Now we have a SignedMessage instance.
  isValid = verify signedMsg

  if isValid
    # Return verified message.
    signedMsg.dumpMessage()
  else
    # Uh oh.
    throw new Error "Unable to verify message signatures."
```

## encode
## decode

## Key Type System

## key

### Symmetric
### Private
### Public
### Shared
### isSymmetric
### isPrivate
### isPublic
### isShared
### equal

## keyPair

### Encryption
### Signature
### isEncryption
### isSignature

# Helpers

## nacl
## hash
## isData
## signedMessage
## isSignedMessage

# Classes
## Key
## SymmetricKey
## PrivateKey
## PublicKey
## SharedKey
## EncryptionKeyPair
## SignatureKeyPair
## SignedMessage


[randombytes]: #randombytes
[encrypt]: #encrypt
[decrypt]: #decrypt
[sign]: #sign
[verify]: #verify
[encode]: #encode
[decode]: #decode
[isData]: #isdata
[hash]: #hash
[nacl]: #nacl

[SymmetricKey]: #symmetric
[PrivateKey]: #private
[PublicKey]: #public
[SharedKey]: #shared
[EncryptionKeyPair]: #encryption
[SignatureKeyPair]: #signature
[isSymmetric]: #issymmetric
[isPrivate]: #isprivate
[isPublic]: #isprivate
[isShared]: #isshared
[isEncryption]: #isencryption
[isSignature]: #issignature
[isSignedMessage]: #issignedmessage
[equal]: #equal

[classKey]: #key
[classSymmetricKey]: #symmetrickey
[classPrivateKey]: #privatekey
[classPublicKey]: #publickey
[classSharedKey]: #sharedkey
[classEncryptionKeyPair]: #encryptionkeypair
[classSignatureKeyPair]: #signaturekeypair
[classSignedMessage]: #signedmessage


[Uint8Array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array
[Buffer]:https://nodejs.org/api/buffer.html


[tweetnacl-random]: https://github.com/dchest/tweetnacl-js#random-bytes-generation
[tweetnacl-secretbox]: https://github.com/dchest/tweetnacl-js#naclsecretboxmessage-nonce-key
[tweetnacl-box-after]: https://github.com/dchest/tweetnacl-js#naclboxaftermessage-nonce-sharedkey
[tweetnacl-secretbox-open]: https://github.com/dchest/tweetnacl-js#naclsecretboxopenbox-nonce-key
[tweetnacl-box-open-after]: https://github.com/dchest/tweetnacl-js#naclboxopenafterbox-nonce-sharedkey
[tweetnacl-sign]: https://github.com/dchest/tweetnacl-js#naclsigndetachedmessage-secretkey
[tweetnacl-verify]: https://github.com/dchest/tweetnacl-js#naclsigndetachedverifymessage-signature-publickey
