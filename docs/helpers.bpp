::

h2 = (s) -> "## #{s}\n\n"
para = "\n\n"
yields = " &rarr; "
maps = " &map; "
it = (f) -> "_#{f()}_"
bold = (f) -> "**#{f()}**"
words = (ax) -> ax.join " "
cat = (ax) -> ax.join ""

list = (a) ->
  (for name, {$o} of a
    if $o then "[ #{name} ]" else name)
    .join ", "
    .replace /\],/, ",]"

returning = (a) ->
  for name, d of a
    return name

ul = (ax) -> cat ("- #{a}#{para}" for a in ax)

alt = (ax) -> ax.join " | "

sig = ({name, $in, $out}) ->
  it ->
    words [
      bold -> name
      list $in
      yields
      returning $out
    ]

_args = (a) ->
  for name, {$t, $d} of a
    cat [
      (it -> name)
      (": #{$t}." if $t?)
      (" #{$d.replace /\s+/g, ' '}" if $d?)
    ]

args = ({$in, $out}) ->
  ul [
    (_args $in)...
    "Returning #{_args $out}"
  ]

_fn = ({name, $in, $out}) ->
  cat [
    sig {name, $in, $out}
    para
    args {name, $in, $out}
  ]

fnH = (name) ->
  addRef name
  cat [
    para
    h2 name
  ]

fn = (x) ->
  $$ cat if x.length?
    [
      fnH x[0].name
      (_fn _x for _x in x)...
    ]
  else
    [
      fnH x.name
      _fn x
    ]

refs = {}
addRef = (s, ref) -> refs[s] = (ref ?= s.toLowerCase())

addRef "Uint8Array"
addRef "Buffer"
addRef "key.Symmetric", "key-symmetric"
addRef "Envelope"
addRef "randomBytes"
addRef "symmetric key", "key-symmetric"
addRef "shared key", "key-shared"
addRef "symmetric encryption", "tweetnacl-secretbox"
addRef "symmetric decryption", "tweetnacl-secretbox-open"
addRef "asymmetric encryption", "tweetnacl-box"
addRef "asymmetric decryption", "tweetnacl-box-open-after"
addRef "key.Public", "class-key-public"
addRef "key.Private", "class-key-private"
addRef "keyPair.Signature", "class-keypair-signature"

ln = (s) ->
  if (ref = refs[s])?
    "[#{s}][#{ref}]"
  else
    "#{s}"

$ln = $ ln

k = (s) ->
  if (ref = refs[s])?
    "[`#{s}`][#{ref}]"
  else
    "`#{s}`"

$k = $ k

bytes = "#{k 'Uint8Array'} | #{k 'Buffer'}"

_include = include

include = (path) ->
  _include path
  $$ "\n\n"

generate =
  toc: ->
  refs: ->
::
